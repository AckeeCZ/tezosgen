// Generated using TezosGen 
// swiftlint:disable file_length

import Foundation
import TezosSwift

/// Struct for function currying
struct {{ contractName }}Box {
    fileprivate let tezosClient: TezosClient 
    fileprivate let at: String

    fileprivate init(tezosClient: TezosClient, at: String) {
       self.tezosClient = tezosClient 
       self.at = at 
    }

    {% if contract.parameter_type != "Void" %}/**
     Call {{ contractName }} with specified params.
     **Important:**
     Params are in the order of how they are specified in the Tezos structure tree
    */
    func call({{ contract.params }}) -> ContractMethodInvocation {
        let send: (_ from: Wallet, _ amount: TezToken, _ completion: @escaping RPCCompletion<String>) -> Void{% if contract.checks %}
        guard {{ contract.checks }} else { 
            send = { from, amount, completion in
                completion(.failure(.parameterError(reason: .orError)))
            }
            return ContractMethodInvocation(send: send)
        }
        {% endif %}
		let input: {{ contract.parameter_type }} = {{ contract.init }} 
        send = { from, amount, completion in
            self.tezosClient.send(amount: amount, to: self.at, from: from, input: input, completion: completion)
        }

        return ContractMethodInvocation(send: send)
    }{% else %}func call() -> ContractMethodInvocation {
        let send: (_ from: Wallet, _ amount: TezToken, _ completion: @escaping RPCCompletion<String>) -> Void = { from, amount, completion in
            self.tezosClient.send(amount: amount, to: self.at, from: from, completion: completion)
        }
    }{% endif %}

    /// Call this method to obtain contract status data
	func status(completion: @escaping RPCCompletion<{% if contract.storage_type != "Void" %}{{ contractName }}Status{% else %}ContractStatus{% endif %}>) {
        let endpoint = "/chains/main/blocks/head/context/contracts/" + at
        tezosClient.sendRPC(endpoint: endpoint, method: .get, completion: completion)
    }
}
{% if contract.storage_type != "Void" %}
/// Status data of {{ contractName }}
struct {{ contractName }}Status: Decodable {
    /// Balance of {{ contractName }} in Tezos
    let balance: Tez
    /// Is contract spendable
    let spendable: Bool
    /// {{ contractName }}'s manager address
    let manager: String
    /// {{ contractName }}'s delegate
    let delegate: StatusDelegate
    /// {{ contractName }}'s current operation counter 
    let counter: Int
    /// {{ contractName }}'s storage
    let storage: {% if contract.simple %}{{ contract.storage_type }}{% else %}{{ contractName }}StatusStorage{% endif %}

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: ContractStatusKeys.self)
        self.balance = try container.decode(Tez.self, forKey: .balance)
        self.spendable = try container.decode(Bool.self, forKey: .spendable)
        self.manager = try container.decode(String.self, forKey: .manager)
        self.delegate = try container.decode(StatusDelegate.self, forKey: .delegate)
        self.counter = try container.decodeRPC(Int.self, forKey: .counter)

        let scriptContainer = try container.nestedContainer(keyedBy: ContractStatusKeys.self, forKey: .script)
        {% if contract.simple %}{% if contract.key == "set" or contract.key == "list" %}self.storage = try scriptContainer.decodeRPC({{ contract.storage_type }}.self, forKey: .storage){% elif contract.key == "map" or contract.key == "big_map" %}self.storage = try scriptContainer.decode({{ contract.storage_internal_type }}.self, forKey: .storage).pairs.map { ($0.first, $0.second) }{% else %}self.storage = try scriptContainer.nestedContainer(keyedBy: StorageKeys.self, forKey: .storage).decodeRPC({{ contract.storage_type }}.self){% endif %}{% elif not contract.key %}
        self.storage = try scriptContainer.nestedContainer(keyedBy: StorageKeys.self, forKey: .storage).decodeRPC({{ contract.storage_type }}.self){% else %}self.storage = try scriptContainer.decode({{ contractName }}StatusStorage.self, forKey: .storage){% endif %}
    }
}{% if not contract.simple %}

/**
 {{ contractName }}'s storage with specified args.
 **Important:**
 Args are in the order of how they are specified in the Tezos structure tree
*/
struct {{ contractName }}StatusStorage: Decodable {
	{{ contract.args }}

    public init(from decoder: Decoder) throws {
        let tezosElement = try decoder.singleValueContainer().decode({{ contract.storage_type }}.self)

		{{ contract.init_args }}
    }
}{% endif %}
{% endif %}
extension TezosClient {
    /**
     This function returns type that you can then use to call {{ contractName }} specified by address.

     - Parameter at: String description of desired address.

     - Returns: Callable type to send Tezos with.
    */
    func {% filter lowerFirstLetter %}{{ contractName }}{% endfilter %}(at: String) -> {{ contractName }}Box {
        return {{ contractName }}Box(tezosClient: self, at: at)
    }
}
